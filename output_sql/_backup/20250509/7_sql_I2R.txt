seed:
/* Creates a table named db with 12 columns: id (bigint), db_name (varchar), driver_class_name (varchar), jdbc_url (varchar), password (varchar), pool_name (varchar), username (varchar), group_name (varchar), balance_type (varchar), minimum_idle (int), maximum_pool_size (int), connection_test_query (varchar). */
CREATE TABLE `db` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `db_name` varchar(255) DEFAULT NULL,
  `driver_class_name` varchar(255) DEFAULT NULL,
  `jdbc_url` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `pool_name` varchar(255) DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  `group_name` varchar(255) DEFAULT '',
  `balance_type` varchar(50) DEFAULT '',
  `minimum_idle` int(11) DEFAULT '1',
  `maximum_pool_size` int(11) DEFAULT '1',
  `connection_test_query` varchar(255) DEFAULT 'SELECT 1',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=7 DEFAULT CHARSET=utf8

description: Creates a table named db with 12 columns: id (bigint), db_name (varchar), driver_class_name (varchar), jdbc_url (varchar), password (varchar), pool_name (varchar), username (varchar), group_name (varchar), balance_type (varchar), minimum_idle (int), maximum_pool_size (int), connection_test_query (varchar).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, VARCHAR, INT, DEFAULT

instruction: Write a SQL query to create a table named db with 12 columns: id (bigint), db_name (varchar), driver_class_name (varchar), jdbc_url (varchar), password (varchar), pool_name (varchar), username (varchar), group_name (varchar), balance_type (varchar), minimum_idle (int), maximum_pool_size (int), connection_test_query (varchar).

response:
-- Reasoning:
We need a new table named db. It should have an integer primary key so that each product has a unique identifier, and a name column to store the product’s name as text.

-- Solution:
CREATE TABLE db (
  id BIGINT,
  db_name VARCHAR(255),
  driver_class_name VARCHAR(255),
  jdbc_url VARCHAR(255),
  password VARCHAR(255),
  pool_name VARCHAR(255),
  username VARCHAR(255),
  group_name VARCHAR(255),
  balance_type VARCHAR(255),
  minimum_idle INT,
  maximum_pool_size INT,
  connection_test_query VARCHAR(255)
);

-- Explanation:
This statement defines the db table with 12 columns:
  - id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - name: variable‐length string up to 255 characters

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('db');

================================================================================

seed:
/* Selects the difference between the d20_sal and d10_sal columns and the difference between the d20_sal and d30_sal columns from the totals_by_dept table. */
select d20_sal - d10_sal as d20_10_diff, d20_sal - d30_sal as d20_30_diff
  from (
    select
      sum(
        case
          when deptno = 10 then sal
        end
      ) as d10_sal,
      sum(
        case
          when deptno = 20 then sal
          end
      ) as d20_sal,
      sum (
        case
          when deptno = 30 then sal
          end
      ) as d30_sal
      from emp
  ) totals_by_dept

description: Selects the difference between the d20_sal and d10_sal columns and the difference between the d20_sal and d30_sal columns from the totals_by_dept table.

concepts: SELECT, SUM, CASE, END, AS, FROM, WHERE, GROUP BY

instruction: Write a SQL query to select the difference between the d20_sal and d10_sal columns and the difference between the d20_sal and d30_sal columns from the totals_by_dept table.

response:
-- Reasoning:
We need to select the difference between the d20_sal and d10_sal columns and the difference between the d20_sal and d30_sal columns from the totals_by_dept table.

-- Solution:
SELECT d20_sal - d10_sal, d20_sal - d30_sal
FROM totals_by_dept;

-- Explanation:
This query selects the difference between the d20_sal and d10_sal columns and the difference between the d20_sal and d30_sal columns from the totals_by_dept table.

-- Tests:
-- 1. Verify the results are correct
SELECT d20_sal - d10_sal, d20_sal - d30_sal
FROM totals_by_dept;

================================================================================

seed:
/* Sets the SQL mode to "NO_AUTO_VALUE_ON_ZERO", which means that the AUTO_INCREMENT value will not be set to 0 when inserting a new row. */
SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO"

description: Sets the SQL mode to "NO_AUTO_VALUE_ON_ZERO", which means that the AUTO_INCREMENT value will not be set to 0 when inserting a new row.

concepts: SET, SQL_MODE, AUTO_INCREMENT, NO_AUTO_VALUE_

instruction: Write a SQL query to set the SQL mode to "NO_AUTO_VALUE_ON_ZERO", which means that the AUTO_INCREMENT value will not be set to 0 when inserting a new row.

response:
-- Reasoning:
We need to set the SQL mode to "NO_AUTO_VALUE_ON_ZERO" so that the AUTO_INCREMENT value will not be set to 0 when inserting a new row.

-- Solution:
SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";

-- Explanation:
This SET statement sets the SQL mode to "NO_AUTO_VALUE_ON_ZERO" to prevent the AUTO_INCREMENT value from being set to 0 when inserting a new row.

-- Tests:
-- 1. Check AUTO_INCREMENT value is not 0
SELECT * FROM orders;

================================================================================

seed:
/* Sets the time zone to UTC. */
SET time_zone = "+00:00"

description: Sets the time zone to UTC.

concepts: SET

instruction: Write a SQL query to set the time zone to UTC.

response:
-- Reasoning:
We need to set the time zone to UTC.

-- Solution:
SET TIMEZONE 'UTC';

-- Explanation:
This statement sets the time zone to UTC.

-- Tests:
-- 1. Check time zone is set to UTC
SELECT TIMEZONE();

================================================================================

seed:
/* Creates a table named user with 9 columns: user_id (integer), age (integer), first_name (varchar), last_name (varchar), gender (varchar), birth_date (varchar), reg_date (varchar), password (varchar), and email (varchar). */
CREATE TABLE `user` (
  `user_id` int(11) NOT NULL,
  `age` int(11) NOT NULL,
  `first_name` varchar(45) NOT NULL,
  `last_name` varchar(45) NOT NULL,
  `gender` varchar(45) NOT NULL,
  `birth_date` varchar(45) NOT NULL,
  `reg_date` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1

description: Creates a table named user with 9 columns: user_id (integer), age (integer), first_name (varchar), last_name (varchar), gender (varchar), birth_date (varchar), reg_date (varchar), password (varchar), and email (varchar).

concepts: CREATE TABLE, INT, VARCHAR, NOT NULL, ENGINE, DEFAULT, CHARSET

instruction: Write a SQL query to create a table named user with 9 columns: user_id (integer), age (integer), first_name (varchar), last_name (varchar), gender (varchar), birth_date (varchar), reg_date (varchar), password (varchar), and email (varchar).

response:
-- Reasoning:
We need a new table named user. It should have an integer primary key so that each user has a unique identifier, and a name column to store the user’s name as text.

-- Solution:
CREATE TABLE user (
  user_id INT PRIMARY KEY,
  age INT,
  first_name VARCHAR(255),
  last_name VARCHAR(255),
  gender VARCHAR(255),
  birth_date VARCHAR(255),
  reg_date VARCHAR(255),
  password VARCHAR(255),
  email VARCHAR(255)
);

-- Explanation:
This statement defines the user table with nine columns:
  - user_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - age: integer
  - first_name: variable‐length string up to 255 characters
  - last_name: variable‐length string up to 255 characters
  - gender: variable‐length string up to 255 characters
  - birth_date: variable‐length string up to 255 characters
  -

================================================================================

seed:
/* Inserts a new user into the users table with the given values. */
INSERT INTO `user` (`user_id`, `age`, `first_name`, `last_name`, `gender`, `birth_date`, `reg_date`, `password`, `email`) VALUES
(11328762, 20, 'Edward', 'Tiro', 'Male', 'November 29, 1996', 'May 15, 2016', 'ef2928350f579b0a0ae3f2c3bf882a27', 'dward@tiro.com')

description: Inserts a new user into the users table with the given values.

concepts: INSERT INTO, VALUES, user_id, age, first_name, last

instruction: Write a SQL query to insert a new user into the users table with the given values.

response:
-- Reasoning:
We need to insert a new user into the users table. The user should have the given values for the columns:
  - user_id: 1
  - name: “”
  - email: “”
  - phone: “1234567890”

-- Solution:
INSERT INTO users (user_id, name, email, phone)
VALUES (1, '', '', '1234567890');

-- Explanation:
This INSERT statement inserts a new row into the users table with the given values.

-- Tests:
-- 1. Verify new user appears in table
SELECT * FROM users;

================================================================================

seed:
/* Drops the table named application_config if it exists. */
DROP TABLE IF EXISTS `application_config`

description: Drops the table named application_config if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named application_config if it exists.

response:
-- Reasoning:
We need to delete the table named application_config if it exists.

-- Solution:
DROP TABLE IF EXISTS application_config;

-- Explanation:
This statement deletes the table named application_config if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('application_config');

================================================================================

seed:
/* Creates a table named application_config with four columns: config_id (integer primary key), config_name (varchar), config_value (varchar), and config_categ (varchar). */
CREATE TABLE `application_config` (
  `config_id` int(11) NOT NULL,
  `config_name` varchar(45) DEFAULT NULL,
  `config_value` varchar(45) DEFAULT NULL,
  `config_categ` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`config_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

description: Creates a table named application_config with four columns: config_id (integer primary key), config_name (varchar), config_value (varchar), and config_categ (varchar).

concepts: CREATE TABLE, PRIMARY KEY, INT, VARCHAR, VARCHAR, VARCHAR

instruction: Write a SQL query to create a table named application_config with four columns: config_id (integer primary key), config_name (varchar), config_value (varchar), and config_categ (varchar).

response:
-- Reasoning:
We need a new table named application_config. It should have an integer primary key so that each config has a unique identifier, and a name column to store the config’s name as text.

-- Solution:
CREATE TABLE application_config (
  config_id INT PRIMARY KEY,
  config_name VARCHAR(255),
  config_value VARCHAR(255),
  config_categ VARCHAR(255)
);

-- Explanation:
This statement defines the application_config table with four columns:
  - config_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - config_name: variable‐length string up to 255 characters
  - config_value: variable‐length string up to 255 characters
  - config_categ: variable‐length string up to 255 characters

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('application_config');

================================================================================

seed:
/* Inserts the values (1,'application_style','preset2.css','UI'),(2,'ENTERPRENEUR_SERVED','200','UI_METRIC'),(3,'PROFESSIONAL_NETWORK','77','UI_METRIC'),(4,'GEOGRAPHIES','7','UI_METRIC'),(5,'TEAM_STRENGTH','27','UI_METRIC'),(6,'INCOME_TAX_INDIVIDULA','299','APPLICATION_AMOUNT */
INSERT INTO `application_config` VALUES (1,'application_style','preset2.css','UI'),(2,'ENTERPRENEUR_SERVED','200','UI_METRIC'),(3,'PROFESSIONAL_NETWORK','77','UI_METRIC'),(4,'GEOGRAPHIES','7','UI_METRIC'),(5,'TEAM_STRENGTH','27','UI_METRIC'),(6,'INCOME_TAX_INDIVIDULA','299','APPLICATION_AMOUNT'),(7,'INCOME_TAX_CORPORATE','199','APPLICATION_AMOUNT'),(8,'IMPORT_EXPORT','3499','APPLICATION_AMOUNT')

description: Inserts the values (1,'application_style','preset2.css','UI'),(2,'ENTERPRENEUR_SERVED','200','UI_METRIC'),(3,'PROFESSIONAL_NETWORK','77','UI_METRIC'),(4,'GEOGRAPHIES','7','UI_METRIC'),(5,'TEAM_STRENGTH','27','UI_METRIC'),(6,'INCOME_TAX_INDIVIDULA','299','APPLICATION_AMOUNT

concepts: INSERT INTO, VALUES, APPLICATION_CONFIG, APPLICATION_STYLE, P

instruction: Write a SQL query to insert the values (1,'application_style','preset2.css','UI'),(2,'ENTERPRENEUR_SERVED','200','UI_METRIC'),(3,'PROFESSIONAL_NETWORK','77','UI_METRIC'),(4,'GEOGRAPHIES','7','UI_METRIC'),(5,'TEAM_STRENGTH','27','UI_METRIC'),(6,'INCOME_TAX_INDIVIDULA','299

response:
-- Reasoning:
We need to insert the values into the table.

-- Solution:
INSERT INTO products (product_id, name)
VALUES (1, 'application_style'),
       (2, 'ENTERPRENEUR_SERVED'),
       (3, 'PROFESSIONAL_NETWORK'),
       (4, 'GEOGRAPHIES'),
       (5, 'TEAM_STRENGTH'),
       (6, 'INCOME_TAX_INDIVIDULA');

-- Explanation:
This statement inserts the values into the products table.

-- Tests:
-- 1. Verify the values are inserted
SELECT * FROM products;

================================================================================

seed:
/* Drops the table named book_keeping_request if it exists. */
DROP TABLE IF EXISTS `book_keeping_request`

description: Drops the table named book_keeping_request if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named book_keeping_request if it exists.

response:
-- Reasoning:
We need to drop the table named book_keeping_request if it exists.

-- Solution:
DROP TABLE IF EXISTS book_keeping_request;

-- Explanation:
This statement drops the table if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('book_keeping_request');

================================================================================

seed:
/* Creates a table named book_keeping_request with seven columns: book_keeping_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime). */
CREATE TABLE `book_keeping_request` (
  `book_keeping_request_id` int(11) NOT NULL AUTO_INCREMENT,
  `requestor_full_name` varchar(50) DEFAULT NULL,
  `requestor_phone_number` varchar(15) DEFAULT NULL,
  `requestor_email_id` varchar(75) DEFAULT NULL,
  `requestor_pan_number` varchar(20) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`book_keeping_request_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

description: Creates a table named book_keeping_request with seven columns: book_keeping_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, VARCHAR, INT, DEFAULT

instruction: Write a SQL query to create a table named book_keeping_request with seven columns: book_keeping_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime).

response:
-- Reasoning:
We need a new table named book_keeping_request. It should have an integer primary key so that each request has a unique identifier, and a name column to store the requestor’s name as text.

-- Solution:
CREATE TABLE book_keeping_request (
  book_keeping_request_id INT PRIMARY KEY,
  requestor_full_name VARCHAR(255),
  requestor_phone_number VARCHAR(255),
  requestor_email_id VARCHAR(255),
  requestor_pan_number VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the book_keeping_request table with seven columns:
  - book_keeping_request_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - requestor_full_name: variable‐length string up to 255 characters
  - requestor_phone_number: variable‐length string up to 255 characters
  - requestor_email_id: variable‐length

================================================================================

seed:
/* Drops the table named companies if it exists. */
DROP TABLE IF EXISTS `companies`

description: Drops the table named companies if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named companies if it exists.

response:
-- Reasoning:
We need to delete the table named companies if it exists.

-- Solution:
DROP TABLE IF EXISTS companies;

-- Explanation:
This statement deletes the table named companies if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('companies');

================================================================================

seed:
/* Creates a table named companies with five columns: company_id (integer primary key), company_name (varchar), company_price (decimal), company_type (varchar), created_dt (datetime), and updated_dt (datetime). */
CREATE TABLE `companies` (
  `company_id` int(11) NOT NULL AUTO_INCREMENT,
  `company_name` varchar(50) DEFAULT NULL,
  `company_price` decimal(10,2) DEFAULT NULL,
  `company_type` varchar(50) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`company_id`),
  UNIQUE KEY `company_id_UNIQUE` (`company_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='Details for company type available'

description: Creates a table named companies with five columns: company_id (integer primary key), company_name (varchar), company_price (decimal), company_type (varchar), created_dt (datetime), and updated_dt (datetime).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, UNIQUE KEY, DEFAULT, COMMENT

instruction: Write a SQL query to create a table named companies with five columns: company_id (integer primary key), company_name (varchar), company_price (decimal), company_type (varchar), created_dt (datetime), and updated_dt (datetime).

response:
-- Reasoning:
We need a new table named companies. It should have an integer primary key so that each company has a unique identifier, and a name column to store the company’s name as text.

-- Solution:
CREATE TABLE companies (
  company_id INT PRIMARY KEY,
  company_name VARCHAR(255),
  company_price DECIMAL,
  company_type VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the companies table with five columns:
  - company_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - company_name: variable‐length string up to 255 characters
  - company_price: decimal number
  - company_type: variable‐length string up to 255 characters
  - created_dt: datetime
  - updated_dt: datetime

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('companies');

================================================================================

seed:
/* Inserts the given values into the companies table. */
INSERT INTO `companies` VALUES (1,'Private Limited',12999.00,NULL,NULL,NULL),(2,'Limited Liability Partnership',9999.00,NULL,NULL,NULL),(3,'One Person Company',11999.00,NULL,NULL,NULL),(4,'Public Limited Company',42999.00,NULL,NULL,NULL),(5,'Nidhi Limited Company',74999.00,NULL,NULL,NULL),(6,'Section 8 Company',25000.00,NULL,NULL,NULL)

description: Inserts the given values into the companies table.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert the given values into the companies table.

response:
-- Reasoning:
We need to insert the given values into the companies table.

-- Solution:
INSERT INTO companies (name, revenue, country)
VALUES ('Facebook', 2000000000, 'USA');

-- Explanation:
This INSERT statement inserts the given values into the companies table.

-- Tests:
-- 1. Verify new row appears
SELECT * FROM companies;

================================================================================

seed:
/* Drops the table named company_request if it exists. */
DROP TABLE IF EXISTS `company_request`

description: Drops the table named company_request if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named company_request if it exists.

response:
-- Reasoning:
We need to drop the table named company_request if it exists.

-- Solution:
DROP TABLE IF EXISTS company_request;

-- Explanation:
This statement drops the table if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('company_request');

================================================================================

seed:
/* Creates a table named company_request with 11 columns: company_request_id (integer primary key), company_name (varchar), requestor_last_name (varchar), requestor_first_name (varchar), requostor_email (varchar), requestor_phone_no (varchar), requestor_pan_no (varchar), company_id (integer), message (varchar), created_dt (datetime), updated_dt (datetime). */
CREATE TABLE `company_request` (
  `company_request_id` int(11) NOT NULL AUTO_INCREMENT,
  `company_name` varchar(100) NOT NULL,
  `requestor_last_name` varchar(50) DEFAULT NULL,
  `requestor_first_name` varchar(50) DEFAULT NULL,
  `requostor_email` varchar(100) DEFAULT NULL,
  `requestor_phone_no` varchar(30) DEFAULT NULL,
  `requestor_pan_no` varchar(30) DEFAULT NULL,
  `company_id` int(11) DEFAULT NULL,
  `message` varchar(2000) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`company_request_id`),
  KEY `company_id_foreign_key_idx` (`company_id`),
  CONSTRAINT `company_id_foreign_key` FOREIGN KEY (`company_id`) REFERENCES `companies` (`company_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Details of company creation '

description: Creates a table named company_request with 11 columns: company_request_id (integer primary key), company_name (varchar), requestor_last_name (varchar), requestor_first_name (varchar), requostor_email (varchar), requestor_phone_no (varchar), requestor_pan_no (varchar), company_id (integer), message (varchar), created_dt (datetime), updated_dt (datetime).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, FOREIGN KEY, CONSTRAINT, KEY

instruction: Write a SQL query to create a table named company_request with 11 columns: company_request_id (integer primary key), company_name (varchar), requestor_last_name (varchar), requestor_first_name (varchar), requostor_email (varchar), requestor_phone_no (varchar), requestor_pan_no (varchar), company_id (integer), message (varchar), created_dt (datetime), updated_dt (datetime).

response:
-- Reasoning:
We need a new table named company_request. It should have an integer primary key so that each request has a unique identifier, and a name column to store the company’s name as text.

-- Solution:
CREATE TABLE company_request (
  company_request_id INT PRIMARY KEY,
  company_name VARCHAR(255),
  requestor_last_name VARCHAR(255),
  requestor_first_name VARCHAR(255),
  requestor_email VARCHAR(255),
  requestor_phone_no VARCHAR(255),
  requestor_pan_no VARCHAR(255),
  company_id INT,
  message VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the company_request table with 11 columns:
  - company_request_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - company_name: variable‐length string up to 255 characters
  - requestor_last_name: variable‐length string up to

================================================================================

seed:
/* Drops the table named gst_request if it exists. */
DROP TABLE IF EXISTS `gst_request`

description: Drops the table named gst_request if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named gst_request if it exists.

response:
-- Reasoning:
We need to delete the table named gst_request if it exists.

-- Solution:
DROP TABLE IF EXISTS gst_request;

-- Explanation:
This statement deletes the table named gst_request if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('gst_request');

================================================================================

seed:
/* Creates a table named gst_request with five columns: gst_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime). */
CREATE TABLE `gst_request` (
  `gst_request_id` int(11) NOT NULL AUTO_INCREMENT,
  `requestor_full_name` varchar(50) DEFAULT NULL,
  `requestor_phone_number` varchar(15) DEFAULT NULL,
  `requestor_email_id` varchar(75) DEFAULT NULL,
  `requestor_pan_number` varchar(20) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`gst_request_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

description: Creates a table named gst_request with five columns: gst_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, VARCHAR, INT, DEFAULT

instruction: Write a SQL query to create a table named gst_request with five columns: gst_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime).

response:
-- Reasoning:
We need a new table named gst_request. It should have an integer primary key so that each request has a unique identifier, and a datetime column to store the request’s creation and update timestamps.

-- Solution:
CREATE TABLE gst_request (
  gst_request_id INT PRIMARY KEY,
  requestor_full_name VARCHAR(255),
  requestor_phone_number VARCHAR(255),
  requestor_email_id VARCHAR(255),
  requestor_pan_number VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the gst_request table with five columns:
  - gst_request_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - requestor_full_name: variable‐length string up to 255 characters
  - requestor_phone_number: variable‐length string up to 255 characters
  - requestor_email_id: variable‐length string up to 255 characters
  - requestor_pan_

================================================================================

seed:
/* Drops the table named import_export_request if it exists. */
DROP TABLE IF EXISTS `import_export_request`

description: Drops the table named import_export_request if it exists.

concepts: DROP TABLE, IF EXISTS

instruction: Write a SQL query to drop the table named import_export_request if it exists.

response:
-- Reasoning:
We need to delete the import_export_request table if it exists.

-- Solution:
DROP TABLE IF EXISTS import_export_request;

-- Explanation:
This statement deletes the import_export_request table if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('import_export_request');

================================================================================

seed:
/* Creates a table named import_export_request with seven columns: import_export_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), and updated_dt (datetime). */
CREATE TABLE `import_export_request` (
  `import_export_request_id` int(11) NOT NULL AUTO_INCREMENT,
  `requestor_full_name` varchar(50) DEFAULT NULL,
  `requestor_phone_number` varchar(15) DEFAULT NULL,
  `requestor_email_id` varchar(50) DEFAULT NULL,
  `requestor_pan_number` varchar(15) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`import_export_request_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

description: Creates a table named import_export_request with seven columns: import_export_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), and updated_dt (datetime).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, VARCHAR, INT, DEFAULT

instruction: Write a SQL query to create a table named import_export_request with seven columns: import_export_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), and updated_dt (datetime).

response:
-- Reasoning:
We need a new table named import_export_request. It should have an integer primary key so that each request has a unique identifier, and a datetime column to store the request’s creation and update timestamps.

-- Solution:
CREATE TABLE import_export_request (
  import_export_request_id INT PRIMARY KEY,
  requestor_full_name VARCHAR(255),
  requestor_phone_number VARCHAR(255),
  requestor_email_id VARCHAR(255),
  requestor_pan_number VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the import_export_request table with seven columns:
  - import_export_request_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - requestor_full_name: variable‐length string up to 255 characters
  - requestor_phone_number: variable‐length string up to 255 characters
  - requestor_email_id: variable‐length string up to 2

================================================================================

seed:
/* Drops the table named income_tax_request if it exists. */
DROP TABLE IF EXISTS `income_tax_request`

description: Drops the table named income_tax_request if it exists.

concepts: DROP TABLE, IF EXISTS

instruction: Write a SQL query to drop the table named income_tax_request if it exists.

response:
-- Reasoning:
We need to drop the table named income_tax_request if it exists.

-- Solution:
DROP TABLE IF EXISTS income_tax_request;

-- Explanation:
This statement drops the table if it exists.

-- Tests:
-- 1. Verify table is gone
PRAGMA table_info('income_tax_request');

================================================================================

seed:
/* Creates a table named income_tax_request with the following columns: income_tax_request_id (integer primary key), requestor_full_name (varchar), requestor_email_id (varchar), requestor_phone_number (varchar), requestor_bank_name (varchar), requestor_ifsc_code (varchar), user_type (varchar), created_dt (datetime), updated_dt (datetime). */
CREATE TABLE `income_tax_request` (
  `income_tax_request_id` int(11) NOT NULL AUTO_INCREMENT,
  `requestor_full_name` varchar(100) DEFAULT NULL,
  `requestor_email_id` varchar(100) DEFAULT NULL,
  `requestor_phone_number` varchar(30) DEFAULT NULL,
  `requestor_bank_name` varchar(45) DEFAULT NULL,
  `requestor_ifsc_code` varchar(45) DEFAULT NULL,
  `user_type` varchar(45) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`income_tax_request_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

description: Creates a table named income_tax_request with the following columns: income_tax_request_id (integer primary key), requestor_full_name (varchar), requestor_email_id (varchar), requestor_phone_number (varchar), requestor_bank_name (varchar), requestor_ifsc_code (varchar), user_type (varchar), created_dt (datetime), updated_dt (datetime).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, VARCHAR, INT, DEFAULT

instruction: Write a SQL query to create a table named income_tax_request with the following columns: income_tax_request_id (integer primary key), requestor_full_name (varchar), requestor_email_id (varchar), requestor_phone_number (varchar), requestor_bank_name (varchar), requestor_ifsc_code (varchar), user_type (varchar), created_dt (datetime), updated_dt (datetime).

response:
-- Reasoning:
We need a new table named income_tax_request. It should have an integer primary key so that each request has a unique identifier, and a name column to store the requestor’s name as text.

-- Solution:
CREATE TABLE income_tax_request (
  income_tax_request_id INT PRIMARY KEY,
  requestor_full_name VARCHAR(255),
  requestor_email_id VARCHAR(255),
  requestor_phone_number VARCHAR(255),
  requestor_bank_name VARCHAR(255),
  requestor_ifsc_code VARCHAR(255),
  user_type VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the income_tax_request table with eight columns:
  - income_tax_request_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - requestor_full_name: variable‐length string up to 255 characters
  - requestor_email_id: variable‐length string up

================================================================================

seed:
/* Drops the table loan_request if it exists. */
DROP TABLE IF EXISTS `loan_request`

description: Drops the table loan_request if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the loan_request table if it exists.

response:
-- Reasoning:
We need to drop the loan_request table if it exists.

-- Solution:
DROP TABLE IF EXISTS loan_request;

-- Explanation:
This DROP statement deletes the loan_request table if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('loan_request');

================================================================================

seed:
/* Creates a table named loan_request with 8 columns: loan_request_id (integer primary key), requestor_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), loan_id (integer), created_dt (datetime), updated_dt (datetime). */
CREATE TABLE `loan_request` (
  `loan_request_id` int(11) NOT NULL AUTO_INCREMENT,
  `requestor_name` varchar(50) DEFAULT NULL,
  `requestor_phone_number` varchar(20) DEFAULT NULL,
  `requestor_email_id` varchar(75) DEFAULT NULL,
  `requestor_pan_number` varchar(15) DEFAULT NULL,
  `loan_id` int(11) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`loan_request_id`),
  KEY `loan_id_foreign_key_idx` (`loan_id`),
  CONSTRAINT `loan_id_foreign_key` FOREIGN KEY (`loan_id`) REFERENCES `loan_types` (`loan_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Loan request from users'

description: Creates a table named loan_request with 8 columns: loan_request_id (integer primary key), requestor_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), loan_id (integer), created_dt (datetime), updated_dt (datetime).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, AUTO_INCREMENT, FOREIGN KEY

instruction: Write a SQL query to create a table named loan_request with 8 columns: loan_request_id (integer primary key), requestor_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), loan_id (integer), created_dt (datetime), updated_dt (datetime).

response:
-- Reasoning:
We need a new table named loan_request. It should have an integer primary key so that each loan request has a unique identifier, and a datetime column to store the date and time when the request was created.

-- Solution:
CREATE TABLE loan_request (
  loan_request_id INT PRIMARY KEY,
  requestor_name VARCHAR(255),
  requestor_phone_number VARCHAR(255),
  requestor_email_id VARCHAR(255),
  requestor_pan_number VARCHAR(255),
  loan_id INT,
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the loan_request table with eight columns:
  - loan_request_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - requestor_name: variable‐length string up to 255 characters
  - requestor_phone_number: variable‐length string up to 255 characters
  - requestor_email_id: variable‐length string up to 255 characters
  - request

================================================================================

seed:
/* Drops the table named loan_types if it exists. */
DROP TABLE IF EXISTS `loan_types`

description: Drops the table named loan_types if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named loan_types if it exists.

response:
-- Reasoning:
We need to delete the loan_types table if it exists.

-- Solution:
DROP TABLE IF EXISTS loan_types;

-- Explanation:
This statement deletes the loan_types table if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('loan_types');

================================================================================

seed:
/* Creates a table named loan_types with three columns: loan_type (varchar), loan_name (varchar), and loan_id (int). */
CREATE TABLE `loan_types` (
  `loan_type` varchar(50) DEFAULT NULL,
  `loan_name` varchar(50) DEFAULT NULL,
  `loan_id` int(11) NOT NULL,
  PRIMARY KEY (`loan_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Types of loans offered by platform'

description: Creates a table named loan_types with three columns: loan_type (varchar), loan_name (varchar), and loan_id (int).

concepts: CREATE TABLE, VARCHAR, INT, PRIMARY KEY

instruction: Write a SQL query to create a table named loan_types with three columns: loan_type (varchar), loan_name (varchar), and loan_id (int).

response:
-- Reasoning:
We need a new table named loan_types. It should have an integer primary key so that each loan type has a unique identifier, and two varchar columns to store the loan type and name.

-- Solution:
CREATE TABLE loan_types (
  loan_id INT PRIMARY KEY,
  loan_type VARCHAR(255),
  loan_name VARCHAR(255)
);

-- Explanation:
This statement defines the loan_types table with three columns:
  - loan_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - loan_type: variable‐length string up to 255 characters
  - loan_name: variable‐length string up to 255 characters

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('loan_types');

================================================================================

seed:
/* Inserts five rows into the loan_types table. */
INSERT INTO `loan_types` VALUES ('Home Loan','Home Loan',1),('Loan Against Property','Loan Against Property',2),('Balance Transfer & Top ups','Balance Transfer & Top ups',3),('Educational Loan','Educational Loan',4),('Term Loan Synidation','Term Loan Synidation',5)

description: Inserts five rows into the loan_types table.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert five rows into the loan_types table.

response:
-- Reasoning:
We need to insert five rows into the loan_types table.

-- Solution:
INSERT INTO loan_types (name, interest_rate)
VALUES ('Home Mortgage', 4.25),
       ('Car Mortgage', 3.75),
       ('Student Mortgage', 3.5),
       ('Personal Mortgage', 3.25),
       ('Business Mortgage', 3.0);

-- Explanation:
This INSERT statement inserts five rows into the loan_types table:
  - name: Home Mortgage, Car Mortgage, Student Mortgage, Personal Mortgage, Business Mortgage
  - interest_rate: 4.25, 3.75, 3.5, 3.25, 3.0

-- Tests:
-- 1. Verify new rows appear
SELECT * FROM loan_types;

================================================================================

seed:
/* Drops the table named paymet_txn_summary if it exists. */
DROP TABLE IF EXISTS `paymet_txn_summary`

description: Drops the table named paymet_txn_summary if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named paymet_txn_summary if it exists.

response:
-- Reasoning:
We need to drop the table named paymet_txn_summary if it exists.

-- Solution:
DROP TABLE IF EXISTS paymet_txn_summary;

-- Explanation:
This DROP statement deletes the table if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('paymet_txn_summary');

================================================================================

seed:
/* Creates a table named paymet_txn_summary with 9 columns: payment_id (integer primary key), payment_txnid (varchar), payu_txnid (varchar), service_request_id (integer), service_type (varchar), amount_paid (varchar), payment_status (varchar), created_dt (datetime), updated_dt (datetime). */
CREATE TABLE `paymet_txn_summary` (
  `payment_id` int(11) NOT NULL AUTO_INCREMENT,
  `payment_txnid` varchar(200) DEFAULT NULL,
  `payu_txnid` varchar(200) DEFAULT NULL,
  `service_request_id` int(11) DEFAULT NULL,
  `service_type` varchar(100) DEFAULT NULL,
  `amount_paid` varchar(500) DEFAULT NULL,
  `payment_status` varchar(45) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`payment_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='To trck payments paid through the site'

description: Creates a table named paymet_txn_summary with 9 columns: payment_id (integer primary key), payment_txnid (varchar), payu_txnid (varchar), service_request_id (integer), service_type (varchar), amount_paid (varchar), payment_status (varchar), created_dt (datetime), updated_dt (datetime).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, AUTO_INCREMENT, DEFAULT

instruction: Write a SQL query to create a table named paymet_txn_summary with 9 columns: payment_id (integer primary key), payment_txnid (varchar), payu_txnid (varchar), service_request_id (integer), service_type (varchar), amount_paid (varchar), payment_status (varchar), created_dt (datetime), updated_dt (datetime).

response:
-- Reasoning:
We need a new table named paymet_txn_summary. It should have an integer primary key so that each payment has a unique identifier, and a name column to store the payment’s name as text.

-- Solution:
CREATE TABLE paymet_txn_summary (
  payment_id INT PRIMARY KEY,
  payment_txnid VARCHAR(255),
  payu_txnid VARCHAR(255),
  service_request_id INT,
  service_type VARCHAR(255),
  amount_paid VARCHAR(255),
  payment_status VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the paymet_txn_summary table with two columns:
  - payment_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - name: variable‐length string up to 255 characters

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('paymet_txn_summary');

================================================================================

seed:
/* Drops the table named registration_service_request if it exists. */
DROP TABLE IF EXISTS `registration_service_request`

description: Drops the table named registration_service_request if it exists.

concepts: DROP TABLE, IF EXISTS

instruction: Write a SQL query to drop the table named registration_service_request if it exists.

response:
-- Reasoning:
We need to delete the table named registration_service_request if it exists.

-- Solution:
DROP TABLE IF EXISTS registration_service_request;

-- Explanation:
This statement deletes the table named registration_service_request if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('registration_service_request');

================================================================================

seed:
/* Creates a table named registration_service_request with the following columns: registration_service_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime), registration_service_type_id (integer). */
CREATE TABLE `registration_service_request` (
  `registration_service_request_id` int(11) NOT NULL AUTO_INCREMENT,
  `requestor_full_name` varchar(50) DEFAULT NULL,
  `requestor_phone_number` varchar(15) DEFAULT NULL,
  `requestor_email_id` varchar(75) DEFAULT NULL,
  `requestor_pan_number` varchar(20) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  `registration_service_type_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`registration_service_request_id`),
  KEY `registration_service_fid_foreign_key_idx` (`registration_service_type_id`),
  CONSTRAINT `registration_service_fid_foreign_key` FOREIGN KEY (`registration_service_type_id`) REFERENCES `registration_service_type` (`service_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8

description: Creates a table named registration_service_request with the following columns: registration_service_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime), registration_service_type_id (integer).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, FOREIGN KEY, REFERENCES, ON

instruction: Write a SQL query to create a table named registration_service_request with the following columns: registration_service_request_id (integer primary key), requestor_full_name (varchar), requestor_phone_number (varchar), requestor_email_id (varchar), requestor_pan_number (varchar), created_dt (datetime), updated_dt (datetime), registration_service_type_id (integer).

response:
-- Reasoning:
We need a new table named registration_service_request. It should have an integer primary key so that each request has a unique identifier, and a datetime column to store the request’s creation and update timestamps.

-- Solution:
CREATE TABLE registration_service_request (
  registration_service_request_id INT PRIMARY KEY,
  requestor_full_name VARCHAR(255),
  requestor_phone_number VARCHAR(255),
  requestor_email_id VARCHAR(255),
  requestor_pan_number VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME,
  registration_service_type_id INT
);

-- Explanation:
This statement defines the registration_service_request table with seven columns:
  - registration_service_request_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - requestor_full_name: variable‐length string up to 255 characters
  - requestor_phone_number: variable‐length string up to 255 characters
  - requestor_email_id

================================================================================

seed:
/* Drops the table named registration_service_type if it exists. */
DROP TABLE IF EXISTS `registration_service_type`

description: Drops the table named registration_service_type if it exists.

concepts: DROP TABLE, IF EXISTS

instruction: Write a SQL query to drop the table named registration_service_type if it exists.

response:
-- Reasoning:
We need to delete the table named registration_service_type if it exists.

-- Solution:
DROP TABLE IF EXISTS registration_service_type;

-- Explanation:
This statement deletes the table named registration_service_type if it exists.

-- Tests:
-- 1. Verify table does not exist
PRAGMA table_info('registration_service_type');

================================================================================

seed:
/* Creates a table named registration_service_type with three columns: service_id (integer primary key), service_name (varchar) and service_type (varchar). */
CREATE TABLE `registration_service_type` (
  `service_id` int(11) NOT NULL AUTO_INCREMENT,
  `service_name` varchar(45) NOT NULL,
  `service_type` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`service_id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8

description: Creates a table named registration_service_type with three columns: service_id (integer primary key), service_name (varchar) and service_type (varchar).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, VARCHAR, INT, DEFAULT

instruction: Write a SQL query to create a table named registration_service_type with three columns: service_id (integer primary key), service_name (varchar) and service_type (varchar).

response:
-- Reasoning:
We need a new table named registration_service_type. It should have an integer primary key so that each service has a unique identifier, and two varchar columns to store the service name and type.

-- Solution:
CREATE TABLE registration_service_type (
  service_id INT PRIMARY KEY,
  service_name VARCHAR(255),
  service_type VARCHAR(255)
);

-- Explanation:
This statement defines the registration_service_type table with three columns:
  - service_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - service_name: variable‐length string up to 255 characters
  - service_type: variable‐length string up to 255 characters

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('registration_service_type');

================================================================================

seed:
/* Inserts the values (1,'FSSAI Food License','license'), (2,'IEC Registration','registration'), (3,'Trade License','license'), (4,'ISO Registration','license'), (5,'Digital Signature (DSC)','license'), (6,'Employee State Insurance (ESI) Registration','license'), (7,'Employees Provident Fund','license'), (8,'Service Tax Registration','registration'), (9,'Sales Tax Registration','registration'), (10,'Prof */
INSERT INTO `registration_service_type` VALUES (1,'FSSAI Food License','license'),(2,'IEC Registration','registration'),(3,'Trade License','license'),(4,'ISO Registration','license'),(5,'Digital Signature (DSC)','license'),(6,'Employee State Insurance (ESI) Registration','license'),(7,'Employees Provident Fund','license'),(8,'Service Tax Registration','registration'),(9,'Sales Tax Registration','registration'),(10,'Professional Tax Registration','registration'),(11,'Excise Tax Registration','registration')

description: Inserts the values (1,'FSSAI Food License','license'), (2,'IEC Registration','registration'), (3,'Trade License','license'), (4,'ISO Registration','license'), (5,'Digital Signature (DSC)','license'), (6,'Employee State Insurance (ESI) Registration','license'), (7,'Employees Provident Fund','license'), (8,'Service Tax Registration','registration'), (9,'Sales Tax Registration','registration'), (10,'Prof

concepts: INSERT INTO, VALUES, license, registration

instruction: Write a SQL query to insert the values (1,'FSSAI Food License','license'), (2,'IEC Registration','registration'), (3,'Trade License','license'), (4,'ISO Registration','license'), (5,'Digital Signature (DSC)','license'), (6,'Employee State Insurance (ESI) Registration','license'), (7,'Employees Provident Fund','license'), (8,'Service Tax Registration','registration'), (9,'Sales Tax Registration','registration'), (

response:
-- Reasoning:
We need to insert the following values into the licenses table:

-- Solution:
INSERT INTO licenses (id, name, type)
VALUES (1, 'FSSAI Food License', 'license'),
       (2, 'IEC Registration', 'registration'),
       (3, 'Trade License', 'license'),
       (4, 'ISO Registration', 'license'),
       (5, 'Digital Signature (DSC)', 'license'),
       (6, 'Employee State Insurance (ESI) Registration', 'license'),
       (7, 'Employees Provident Fund', 'license'),
       (8, 'Service Tax Registration', 'registration'),
       (9, 'Sales Tax Registration', 'registration');

-- Explanation:
This INSERT statement inserts the values into the licenses table.

-- Tests:
-- 1. Verify new values are inserted
SELECT * FROM licenses;

================================================================================

seed:
/* Drops the table named user_query if it exists. */
DROP TABLE IF EXISTS `user_query`

description: Drops the table named user_query if it exists.

concepts: DROP TABLE

instruction: Write a SQL query to drop the table named user_query if it exists.

response:
-- Reasoning:
We need to delete the table named user_query if it exists.

-- Solution:
DROP TABLE IF EXISTS user_query;

-- Explanation:
This statement deletes the table named user_query if it exists.

-- Tests:
-- 1. Verify table is gone
PRAGMA table_info('user_query');

================================================================================

seed:
/* Creates a table named user_query with seven columns: query_id (integer primary key), full_name (varchar), subject (varchar), message (text), email_id (varchar), created_dt (datetime), and updated_dt (datetime). */
CREATE TABLE `user_query` (
  `query_id` int(11) NOT NULL AUTO_INCREMENT,
  `full_name` varchar(55) DEFAULT NULL,
  `subject` varchar(100) DEFAULT NULL,
  `message` text,
  `email_id` varchar(50) DEFAULT NULL,
  `created_dt` datetime DEFAULT NULL,
  `updated_dt` datetime DEFAULT NULL,
  PRIMARY KEY (`query_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

description: Creates a table named user_query with seven columns: query_id (integer primary key), full_name (varchar), subject (varchar), message (text), email_id (varchar), created_dt (datetime), and updated_dt (datetime).

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, VARCHAR, INT, DEFAULT

instruction: Write a SQL query to create a table named user_query with seven columns: query_id (integer primary key), full_name (varchar), subject (varchar), message (text), email_id (varchar), created_dt (datetime), and updated_dt (datetime).

response:
-- Reasoning:
We need a new table named user_query. It should have an integer primary key so that each query has a unique identifier, and a name column to store the user’s full name as text.

-- Solution:
CREATE TABLE user_query (
  query_id INT PRIMARY KEY,
  full_name VARCHAR(255),
  subject VARCHAR(255),
  message TEXT,
  email_id VARCHAR(255),
  created_dt DATETIME,
  updated_dt DATETIME
);

-- Explanation:
This statement defines the user_query table with seven columns:
  - query_id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - full_name: variable‐length string up to 255 characters
  - subject: variable‐length string up to 255 characters
  - message: text
  - email_id: variable‐length string up to 255 characters
  - created_dt: datetime
  - updated_dt: datetime

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_

================================================================================

seed:
/* Drops the database named libraryautomation. */
drop database libraryautomation

description: Drops the database named libraryautomation.

concepts: drop database

instruction: Write a SQL query to drop the database named libraryautomation.

response:
-- Reasoning:
We need to delete the database named libraryautomation.

-- Solution:
DROP DATABASE libraryautomation;

-- Explanation:
This statement deletes the database named libraryautomation.

-- Tests:
-- 1. Verify database is deleted
SELECT name FROM sqlite_master WHERE type='database';

================================================================================

seed:
/* Creates a database named libraryautomation. */
create database libraryautomation

description: Creates a database named libraryautomation.

concepts: create database

instruction: Write a SQL query to create a database named libraryautomation.

response:
-- Reasoning:
We need to create a new database named libraryautomation.

-- Solution:
CREATE DATABASE libraryautomation;

-- Explanation:
This statement creates a new database named libraryautomation.

-- Tests:
-- 1. Verify database exists
SELECT name FROM sqlite_master WHERE type='database';

================================================================================

seed:
/* Creates a table named book with seven columns: BookId (integer primary key), BookName (varchar), author (varchar), Press (varchar), Price (varchar), Position (varchar), ISBN (varchar), status (varchar), Category (varchar), description (text), number (integer). */
create table book(
	BookId int(6)  unsigned zerofill auto_increment not null,
    BookName varchar(255) not null,
    author varchar(255) not null,
    Press varchar(255) not null,
    Price varchar(255) not null,
    Position varchar(255) not null,
    ISBN varchar(255) not null,
    status varchar(255) not null, -- available/reserved/lent
    Category varchar(255) not null,
    description text,
    
    number int not null,
    PRIMARY KEY (BookId)
)

description: Creates a table named book with seven columns: BookId (integer primary key), BookName (varchar), author (varchar), Press (varchar), Price (varchar), Position (varchar), ISBN (varchar), status (varchar), Category (varchar), description (text), number (integer).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, TEXT, INT, AUTO_

instruction: Write a SQL query to create a table named book with seven columns: BookId (integer primary key), BookName (varchar), author (varchar), Press (varchar), Price (varchar), Position (varchar), ISBN (varchar), status (varchar), Category (varchar), description (text), number (integer).

response:
-- Reasoning:
We need a new table named book. It should have an integer primary key so that each book has a unique identifier, and a name column to store the book’s name as text.

-- Solution:
CREATE TABLE book (
  BookId INT PRIMARY KEY,
  BookName VARCHAR(255),
  author VARCHAR(255),
  Press VARCHAR(255),
  Price VARCHAR(255),
  Position VARCHAR(255),
  ISBN VARCHAR(255),
  status VARCHAR(255),
  Category VARCHAR(255),
  description TEXT,
  number INT
);

-- Explanation:
This statement defines the book table with two columns:
  - BookId: integer, marked PRIMARY KEY so it cannot be null and is unique
  - BookName: variable‐length string up to 255 characters

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('book');

================================================================================

seed:
/* Creates a table named bookrecord with five columns: informationId (integer primary key), FineValue (float), LentDate (datetime), ReturnDate (datetime), BookId (integer), AcntNum (integer). */
create table bookrecord(
	informationId int(6)  unsigned zerofill auto_increment not null,
    FineValue float,
    LentDate DATETIME not null,
    ReturnDate DATETIME,
    BookId int(6) unsigned zerofill not null,
    AcntNum int(6) unsigned zerofill not null,
    PRIMARY KEY (informationId)
    
)

description: Creates a table named bookrecord with five columns: informationId (integer primary key), FineValue (float), LentDate (datetime), ReturnDate (datetime), BookId (integer), AcntNum (integer).

concepts: CREATE TABLE, INT, PRIMARY KEY, FLOAT, DATETIME, DATETIME

instruction: Write a SQL query to create a table named bookrecord with five columns: informationId (integer primary key), FineValue (float), LentDate (datetime), ReturnDate (datetime), BookId (integer), AcntNum (integer).

response:
-- Reasoning:
We need a new table named bookrecord. It should have an integer primary key so that each record has a unique identifier, and a name column to store the product’s name as text.

-- Solution:
CREATE TABLE bookrecord (
  informationId INT PRIMARY KEY,
  FineValue FLOAT,
  LentDate DATETIME,
  ReturnDate DATETIME,
  BookId INT,
  AcntNum INT
);

-- Explanation:
This statement defines the bookrecord table with five columns:
  - informationId: integer, marked PRIMARY KEY so it cannot be null and is unique
  - FineValue: float
  - LentDate: datetime
  - ReturnDate: datetime
  - BookId: integer
  - AcntNum: integer

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('bookrecord');

================================================================================

seed:
/* Creates a table named optionRecord with five columns: informationId (integer primary key), BookId (integer), AcntNum (integer), reason (varchar), operation (varchar), creationDate (datetime). */
create table optionRecord(
	informationId int(6)  unsigned zerofill auto_increment not null,
	BookId int(6) unsigned zerofill not null,
    AcntNum int(6) unsigned zerofill not null,
	reason  varchar(255),
	operation varchar(255) not null,
	creationDate DATETIME not null,
	PRIMARY KEY (informationId)
	
	
)

description: Creates a table named optionRecord with five columns: informationId (integer primary key), BookId (integer), AcntNum (integer), reason (varchar), operation (varchar), creationDate (datetime).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, DATETIME

instruction: Write a SQL query to create a table named optionRecord with five columns: informationId (integer primary key), BookId (integer), AcntNum (integer), reason (varchar), operation (varchar), creationDate (datetime).

response:
-- Reasoning:
We need a new table named optionRecord. It should have an integer primary key so that each record has a unique identifier, and four other columns to store the information about the option record.

-- Solution:
CREATE TABLE optionRecord (
  informationId INT PRIMARY KEY,
  BookId INT,
  AcntNum INT,
  reason VARCHAR(255),
  operation VARCHAR(255),
  creationDate DATETIME
);

-- Explanation:
This statement defines the optionRecord table with five columns:
  - informationId: integer, marked PRIMARY KEY so it cannot be null and is unique
  - BookId: integer
  - AcntNum: integer
  - reason: variable‐length string up to 255 characters
  - operation: variable‐length string up to 255 characters
  - creationDate: datetime

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('optionRecord');

================================================================================

seed:
/* Creates a table named reserve with three columns: informationId (integer primary key), BookId (integer), AcntNum (integer), and createDate (datetime). */
create table reserve(
	informationId int(6)  unsigned zerofill auto_increment not null,
	BookId int(6) unsigned zerofill not null,
    AcntNum int(6)  unsigned zerofill  not null,
	createDate DATETIME not null,
	PRIMARY KEY (informationId)
)

description: Creates a table named reserve with three columns: informationId (integer primary key), BookId (integer), AcntNum (integer), and createDate (datetime).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, DATETIME

instruction: Write a SQL query to create a table named reserve with three columns: informationId (integer primary key), BookId (integer), AcntNum (integer), and createDate (datetime).

response:
-- Reasoning:
We need a new table named reserve. It should have an integer primary key so that each reservation has a unique identifier, and two foreign keys to the books and accounts tables.

-- Solution:
CREATE TABLE reserve (
  informationId INT PRIMARY KEY,
  BookId INT,
  AcntNum INT,
  createDate DATETIME
);

-- Explanation:
This statement defines the reserve table with four columns:
  - informationId: integer, marked PRIMARY KEY so it cannot be null and is unique
  - BookId: integer, foreign key to the books table
  - AcntNum: integer, foreign key to the accounts table
  - createDate: datetime, the date and time the reservation was created

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('reserve');

================================================================================

seed:
/* Creates a table named reader with five columns: AcntNum (integer primary key), Telephone (varchar), Password (varchar), Email (varchar), bookNumber (integer), registerDate (datetime), Deposit (float). */
create table reader(
	AcntNum int(6)  unsigned zerofill auto_increment not null,
	Telephone varchar(255) not null,
    Password varchar(255) not null,
    Email varchar(255) not null,
    bookNumber int not null,
    registerDate DATETIME not null,
    Deposit float not null,
    PRIMARY KEY(AcntNum)
)

description: Creates a table named reader with five columns: AcntNum (integer primary key), Telephone (varchar), Password (varchar), Email (varchar), bookNumber (integer), registerDate (datetime), Deposit (float).

concepts: CREATE TABLE, INT, PRIMARY KEY, VARCHAR, DATETIME, FLOAT

instruction: Write a SQL query to create a table named reader with five columns: AcntNum (integer primary key), Telephone (varchar), Password (varchar), Email (varchar), bookNumber (integer), registerDate (datetime), Deposit (float).

response:
-- Reasoning:
We need a new table named reader. It should have an integer primary key so that each reader has a unique identifier, and a name column to store the reader’s name as text.

-- Solution:
CREATE TABLE reader (
  AcntNum INT PRIMARY KEY,
  Telephone VARCHAR(255),
  Password VARCHAR(255),
  Email VARCHAR(255),
  bookNumber INT,
  registerDate DATETIME,
  Deposit FLOAT
);

-- Explanation:
This statement defines the reader table with five columns:
  - AcntNum: integer, marked PRIMARY KEY so it cannot be null and is unique
  - Telephone: variable‐length string up to 255 characters
  - Password: variable‐length string up to 255 characters
  - Email: variable‐length string up to 255 characters
  - bookNumber: integer
  - registerDate: datetime
  - Deposit: float

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('reader');

================================================================================

seed:
/* Creates a table named librarian with two columns: AcntNum (varchar) and Password (varchar). AcntNum is the primary key of the table. */
create table librarian(
	AcntNum varchar(255) not null,
    Password varchar(255) not null,
    PRIMARY KEY(AcntNum)
)

description: Creates a table named librarian with two columns: AcntNum (varchar) and Password (varchar). AcntNum is the primary key of the table.

concepts: CREATE TABLE, VARCHAR, PRIMARY KEY

instruction: Write a SQL query to create a table named librarian with two columns: AcntNum (varchar) and Password (varchar). AcntNum is the primary key of the table.

response:
-- Reasoning:
We need a new table named librarian. It should have an integer primary key so that each librarian has a unique identifier, and a name column to store the librarian’s name as text.

-- Solution:
CREATE TABLE librarian (
  AcntNum VARCHAR(255) PRIMARY KEY,
  Password VARCHAR(255)
);

-- Explanation:
This statement defines the librarian table with two columns:
  - AcntNum: varchar, marked PRIMARY KEY so it cannot be null and is unique
  - Password: varchar

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('librarian');

================================================================================

seed:
/* Creates a table named admin with two columns: AcntNum (varchar) and Password (varchar). AcntNum is the primary key of the table. */
create table admin(
	AcntNum varchar(255) not null,
    Password varchar(255) not null,
    PRIMARY KEY(AcntNum)
)

description: Creates a table named admin with two columns: AcntNum (varchar) and Password (varchar). AcntNum is the primary key of the table.

concepts: CREATE TABLE, VARCHAR, PRIMARY KEY

instruction: Write a SQL query to create a table named admin with two columns: AcntNum (varchar) and Password (varchar). AcntNum is the primary key of the table.

response:
-- Reasoning:
We need a new table named admin. It should have an integer primary key so that each product has a unique identifier, and a name column to store the product’s name as text.

-- Solution:
CREATE TABLE admin (
  AcntNum VARCHAR(255) PRIMARY KEY,
  Password VARCHAR(255)
);

-- Explanation:
This statement defines the admin table with two columns:
  - AcntNum: varchar, marked PRIMARY KEY so it cannot be null and is unique
  - Password: varchar

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('admin');

================================================================================

seed:
/* Creates a table named announcement with three columns: TextId (varchar), Text (text), and Date (datetime). TextId is the primary key of the table. */
create table announcement(
	TextId varchar(255) not null,
    Text text not null,
    Date DATETIME not null,
    PRIMARY KEY(TextId)
)

description: Creates a table named announcement with three columns: TextId (varchar), Text (text), and Date (datetime). TextId is the primary key of the table.

concepts: CREATE TABLE, VARCHAR, TEXT, DATETIME, PRIMARY KEY

instruction: Write a SQL query to create a table named announcement with three columns: TextId (varchar), Text (text), and Date (datetime). TextId is the primary key of the table.

response:
-- Reasoning:
We need a new table named announcement. It should have a primary key named TextId, a text column named Text, and a datetime column named Date.

-- Solution:
CREATE TABLE announcement (
  TextId VARCHAR(255) PRIMARY KEY,
  Text TEXT,
  Date DATETIME
);

-- Explanation:
This statement defines the announcement table with three columns:
  - TextId: variable‐length string up to 255 characters, marked PRIMARY KEY so it cannot be null and is unique
  - Text: variable‐length text
  - Date: datetime

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('announcement');

================================================================================

seed:
/* Creates a foreign key constraint on the acntnum column of the optionRecord table that references the acntnum column of the reader table. */
alter table optionRecord
add constraint reader_optionRecord foreign key (`acntnum`)
references reader(`acntnum`) on update cascade on delete CASCADE

description: Creates a foreign key constraint on the acntnum column of the optionRecord table that references the acntnum column of the reader table.

concepts: alter table, add constraint, foreign key, references, on update, on delete

instruction: Write a SQL query to create a foreign key constraint on the acntnum column of the optionRecord table that references the acntnum column of the reader table.

response:
-- Reasoning:
We need to create a foreign key constraint on the optionRecord table to reference the reader table. This will ensure that the acntnum column of the optionRecord table is always valid.

-- Solution:
ALTER TABLE optionRecord
  ADD CONSTRAINT fk_optionRecord_reader
    FOREIGN KEY (acntnum)
    REFERENCES reader (acntnum);

-- Explanation:
This ALTER statement adds a foreign key constraint to the optionRecord table that references the reader table.

-- Tests:
-- 1. Check new constraint appears
PRAGMA foreign_key_list('optionRecord');

================================================================================

seed:
/* Creates a foreign key constraint on the bookId column of the optionRecord table that references the bookId column of the book table. */
alter table optionRecord
add constraint book_optionRecord foreign key (`bookId`)
references book(`bookId`) on update cascade on delete CASCADE

description: Creates a foreign key constraint on the bookId column of the optionRecord table that references the bookId column of the book table.

concepts: alter table, add constraint, foreign key, references, on update, on delete

instruction: Write a SQL query to create a foreign key constraint on the bookId column of the optionRecord table that references the bookId column of the book table.

response:
-- Reasoning:
We need to create a foreign key constraint on the optionRecord table to ensure that the bookId column references the bookId column of the book table.

-- Solution:
ALTER TABLE optionRecord
  ADD CONSTRAINT fk_bookId FOREIGN KEY (bookId) REFERENCES book(bookId);

-- Explanation:
This ALTER statement adds a foreign key constraint to the optionRecord table that references the bookId column of the book table.

-- Tests:
-- 1. Check foreign key constraint exists
PRAGMA foreign_key_list('optionRecord');

================================================================================

seed:
/* Creates a foreign key constraint on the acntnum column of the reserve table that references the acntnum column of the reader table. */
alter table reserve
add constraint reader_reserve foreign key (`acntnum`)
references reader(`acntnum`) on update cascade on delete CASCADE

description: Creates a foreign key constraint on the acntnum column of the reserve table that references the acntnum column of the reader table.

concepts: ALTER TABLE, ADD CONSTRAINT, FOREIGN KEY, REFERENCES, ON UPDATE, ON DELETE

instruction: Write a SQL query to create a foreign key constraint on the acntnum column of the reserve table that references the acntnum column of the reader table.

response:
-- Reasoning:
We need to create a foreign key constraint on the acntnum column of the reserve table that references the acntnum column of the reader table.

-- Solution:
ALTER TABLE reserve
  ADD CONSTRAINT fk_acntnum
  FOREIGN KEY (acntnum)
  REFERENCES reader (acntnum);

-- Explanation:
This ALTER statement adds a foreign key constraint to the reserve table. The constraint ensures that the acntnum column of the reserve table references the acntnum column of the reader table.

-- Tests:
-- 1. Check new constraint appears
PRAGMA foreign_key_list('reserve');

================================================================================

seed:
/* Creates a foreign key constraint on the bookId column of the reserve table that references the bookId column of the book table. */
alter table reserve
add constraint book_reserve foreign key (`bookId`)
references book(`bookId`) on update cascade on delete CASCADE

description: Creates a foreign key constraint on the bookId column of the reserve table that references the bookId column of the book table.

concepts: alter table, add constraint, foreign key, references, on update, on delete

instruction: Write a SQL query to create a foreign key constraint on the bookId column of the reserve table that references the bookId column of the book table.

response:
-- Reasoning:
We need to create a foreign key constraint on the bookId column of the reserve table that references the bookId column of the book table.

-- Solution:
ALTER TABLE reserve
  ADD CONSTRAINT fk_bookId
    FOREIGN KEY (bookId)
      REFERENCES book(bookId);

-- Explanation:
This ALTER statement adds a foreign key constraint to the reserve table. The constraint ensures that the bookId column of the reserve table references the bookId column of the book table.

-- Tests:
-- 1. Check foreign key constraint exists
PRAGMA foreign_key_list('reserve');

================================================================================

seed:
/* Creates a foreign key constraint on the acntnum column of the bookrecord table that references the acntnum column of the reader table. */
alter table bookrecord
add constraint reader_bookrecord foreign key (`acntnum`)
references reader(`acntnum`) on update cascade on delete CASCADE

description: Creates a foreign key constraint on the acntnum column of the bookrecord table that references the acntnum column of the reader table.

concepts: alter table, add constraint, foreign key, references, on update, on delete

instruction: Write a SQL query to create a foreign key constraint on the acntnum column of the bookrecord table that references the acntnum column of the reader table.

response:
-- Reasoning:
We need to create a foreign key constraint on the bookrecord table to reference the reader table. This means that the acntnum column of the bookrecord table should be a foreign key that references the acntnum column of the reader table.

-- Solution:
ALTER TABLE bookrecord
  ADD CONSTRAINT fk_bookrecord_reader
    FOREIGN KEY (acntnum)
    REFERENCES reader (acntnum);

-- Explanation:
This ALTER statement adds a foreign key constraint to the bookrecord table. The constraint is named fk_bookrecord_reader and it references the reader table. The acntnum column of the bookrecord table is the foreign key and the acntnum column of the reader table is the primary key.

-- Tests:
-- 1. Check foreign key constraint exists
PRAGMA foreign_key_list('bookrecord');

================================================================================

seed:
/* Adds a foreign key constraint to the bookrecord table that references the book table. */
alter table bookrecord
add constraint book_bookrecord foreign key (`bookId`)
references book(`bookId`) on update cascade on delete CASCADE

description: Adds a foreign key constraint to the bookrecord table that references the book table.

concepts: alter table, add constraint, foreign key, references, on update, on delete

instruction: Write a SQL query to add a foreign key constraint to the bookrecord table that references the book table.

response:
-- Reasoning:
We need to add a foreign key constraint to the bookrecord table that references the book table. This means that every book record must have a corresponding book in the book table.

-- Solution:
ALTER TABLE bookrecord
  ADD CONSTRAINT fk_bookrecord_book
    FOREIGN KEY (book_id)
      REFERENCES book (book_id);

-- Explanation:
This ALTER statement adds a foreign key constraint to the bookrecord table that references the book table.

-- Tests:
-- 1. Check new constraint appears
PRAGMA foreign_key_list('bookrecord');

================================================================================

seed:
/* Adds a new column named IMAGE_DATA to the EMPLOYEE table in the PUBLIC schema. The column is of type BLOB and can hold null values. */
ALTER TABLE PUBLIC.EMPLOYEE ADD IMAGE_DATA BLOB NULL

description: Adds a new column named IMAGE_DATA to the EMPLOYEE table in the PUBLIC schema. The column is of type BLOB and can hold null values.

concepts: ALTER TABLE, ADD, BLOB, NULL

instruction: Write a SQL query to add a new column named IMAGE_DATA to the EMPLOYEE table in the PUBLIC schema. The column is of type BLOB and can hold null values.

response:
-- Reasoning:
We need to add a new column named IMAGE_DATA to the EMPLOYEE table in the PUBLIC schema. It should be a BLOB and can hold null values.

-- Solution:
ALTER TABLE PUBLIC.EMPLOYEE
  ADD COLUMN IMAGE_DATA BLOB;

-- Explanation:
This ALTER statement updates the EMPLOYEE table schema by adding:
  - IMAGE_DATA: a BLOB column that can hold null values

-- Tests:
-- 1. Verify new column appears
PRAGMA table_info('EMPLOYEE');

================================================================================

seed:
/* Creates a unique index named productbin_name_ind on the table_productbin table. The index is on the parent_type, parent_id, and NAME columns. */
CREATE UNIQUE INDEX sa.productbin_name_ind ON sa.table_productbin(parent_type,parent_id,"NAME")

description: Creates a unique index named productbin_name_ind on the table_productbin table. The index is on the parent_type, parent_id, and NAME columns.

concepts: CREATE UNIQUE INDEX, ON, parent_type, parent_id, NAME

instruction: Write a SQL query to create a unique index named productbin_name_ind on the table_productbin table. The index is on the parent_type, parent_id, and NAME columns.

response:
-- Reasoning:
We need to create a unique index on the table_productbin table. The index should be on the parent_type, parent_id, and NAME columns.

-- Solution:
CREATE UNIQUE INDEX productbin_name_ind ON table_productbin (parent_type, parent_id, NAME);

-- Explanation:
This statement creates a unique index named productbin_name_ind on the table_productbin table. The index is on the parent_type, parent_id, and NAME columns.

-- Tests:
-- 1. Verify index exists
PRAGMA index_list('table_productbin');

================================================================================

seed:
/* Creates a table named chicken_lineage with four columns: id (integer primary key), lineage (varchar), chicken_color (varchar), and provider (varchar). */
CREATE TABLE chicken_lineage (
	id INT NOT NULL AUTO_INCREMENT,
	lineage VARCHAR(15) NOT NULL,
    chicken_color VARCHAR(15) NOT NULL,
    provider VARCHAR(15) NOT NULL,
	PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4

description: Creates a table named chicken_lineage with four columns: id (integer primary key), lineage (varchar), chicken_color (varchar), and provider (varchar).

concepts: CREATE TABLE, NOT NULL, AUTO_INCREMENT, PRIMARY KEY, ENGINE, DEFAULT

instruction: Write a SQL query to create a table named chicken_lineage with four columns: id (integer primary key), lineage (varchar), chicken_color (varchar), and provider (varchar).

response:
-- Reasoning:
We need a new table named chicken_lineage. It should have an integer primary key so that each chicken has a unique identifier, and a lineage column to store the chicken’s lineage as text.

-- Solution:
CREATE TABLE chicken_lineage (
  id INT PRIMARY KEY,
  lineage VARCHAR(255),
  chicken_color VARCHAR(255),
  provider VARCHAR(255)
);

-- Explanation:
This statement defines the chicken_lineage table with four columns:
  - id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - lineage: variable‐length string up to 255 characters
  - chicken_color: variable‐length string up to 255 characters
  - provider: variable‐length string up to 255 characters

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('chicken_lineage');

================================================================================

seed:
/* Creates a table named shed_manufacturer with three columns: id (integer primary key), manufacturer (varchar), and active (boolean). */
CREATE TABLE shed_manufacturer (
	id INT NOT NULL AUTO_INCREMENT,
	manufacturer VARCHAR(15) NOT NULL,
	PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4

description: Creates a table named shed_manufacturer with three columns: id (integer primary key), manufacturer (varchar), and active (boolean).

concepts: CREATE TABLE, INT, NOT NULL, AUTO_INCREMENT, PRIMARY KEY, VARCHAR

instruction: Write a SQL query to create a table named shed_manufacturer with three columns: id (integer primary key), manufacturer (varchar), and active (boolean).

response:
-- Reasoning:
We need a new table named shed_manufacturer. It should have an integer primary key so that each manufacturer has a unique identifier, a name column to store the manufacturer’s name as text, and an active column to indicate whether the manufacturer is still active.

-- Solution:
CREATE TABLE shed_manufacturer (
  id INTEGER PRIMARY KEY,
  manufacturer VARCHAR(255),
  active BOOLEAN
);

-- Explanation:
This statement defines the shed_manufacturer table with three columns:
  - id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - manufacturer: variable‐length string up to 255 characters
  - active: boolean

-- Tests:
-- 1. Verify table exists and schema is correct
PRAGMA table_info('shed_manufacturer');

================================================================================

seed:
/* Creates a table named shed with five columns: id (integer primary key), name (varchar), type (varchar), capacity (integer), model (varchar), and shed_manufacturer_id (integer). The shed_manufacturer_id column is a foreign key that references the id column in the shed_manufacturer table. */
CREATE TABLE shed (
  id INT NOT NULL AUTO_INCREMENT,
  name VARCHAR(15) NOT NULL,
  type VARCHAR(15) NOT NULL,
  capacity INT NOT NULL,
  model VARCHAR(15) NOT NULL,
  shed_manufacturer_id  INT NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (shed_manufacturer_id) REFERENCES shed_manufacturer(id)
) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4

description: Creates a table named shed with five columns: id (integer primary key), name (varchar), type (varchar), capacity (integer), model (varchar), and shed_manufacturer_id (integer). The shed_manufacturer_id column is a foreign key that references the id column in the shed_manufacturer table.

concepts: CREATE TABLE, NOT NULL, AUTO_INCREMENT, PRIMARY KEY, FOREIGN KEY

instruction: Write a SQL query to create a table named shed with five columns: id (integer primary key), name (varchar), type (varchar), capacity (integer), model (varchar), and shed_manufacturer_id (integer). The shed_manufacturer_id column is a foreign key that references the id column in the shed_manufacturer table.

response:
-- Reasoning:
We need a new table named shed. It should have an integer primary key so that each shed has a unique identifier, and a name column to store the shed’s name as text.

-- Solution:
CREATE TABLE shed (
  id INT PRIMARY KEY,
  name VARCHAR(255),
  type VARCHAR(255),
  capacity INT,
  model VARCHAR(255),
  shed_manufacturer_id INT,
  FOREIGN KEY (shed_manufacturer_id) REFERENCES shed_manufacturer(id)
);

-- Explanation:
This statement defines the shed table with five columns:
  - id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - name: variable‐length string up to 255 characters
  - type: variable‐length string up to 255 characters
  - capacity: integer
  - model: variable‐length string up to 255 characters
  - shed_manufacturer_id: integer, foreign key to shed_manufacturer.id

-- Tests:
-- 1. Verify table exists and schema is

================================================================================

seed:
/* Creates a table named chicken_lot with seven columns: id (integer primary key), birth_date (date), accommodation_date (date), initial_quantity (integer), current_quantity (integer), debicking (varchar), chicken_lineage_id (integer), and shed_id (integer). The id column is set to auto increment, the birth_date and accommodation_date columns are set to not null, and the initial_quantity, */
CREATE TABLE chicken_lot (
  id INT NOT NULL AUTO_INCREMENT,
  birth_date DATE NOT NULL,
  accommodation_date DATE NOT NULL,
  initial_quantity INT NOT NULL,
  current_quantity INT NOT NULL,
  debicking VARCHAR(15) NOT NULL,
  chicken_lineage_id  INT NOT NULL,
  shed_id  INT NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (chicken_lineage_id) REFERENCES chicken_lineage(id),
  FOREIGN KEY (shed_id) REFERENCES shed(id)
) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4

description: Creates a table named chicken_lot with seven columns: id (integer primary key), birth_date (date), accommodation_date (date), initial_quantity (integer), current_quantity (integer), debicking (varchar), chicken_lineage_id (integer), and shed_id (integer). The id column is set to auto increment, the birth_date and accommodation_date columns are set to not null, and the initial_quantity,

concepts: CREATE TABLE, AUTO_INCREMENT, PRIMARY KEY, FOREIGN KEY, REFERENCES, ENGINE

instruction: Write a SQL query to create a table named chicken_lot with seven columns: id (integer primary key), birth_date (date), accommodation_date (date), initial_quantity (integer), current_quantity (integer), debicking (varchar), chicken_lineage_id (integer), and shed_id (integer). The id column is set to auto increment, the birth_date and accommodation_date columns are set to not null, and

response:
-- Reasoning:
We need a new table named chicken_lot. It should have an integer primary key so that each chicken lot has a unique identifier, and a birth_date and accommodation_date column to store the chicken’s birth and accommodation dates.

-- Solution:
CREATE TABLE chicken_lot (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  birth_date DATE NOT NULL,
  accommodation_date DATE NOT NULL,
  initial_quantity INTEGER,
  current_quantity INTEGER,
  debicking VARCHAR(255),
  chicken_lineage_id INTEGER,
  shed_id INTEGER
);

-- Explanation:
This statement defines the chicken_lot table with seven columns:
  - id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - birth_date: date, not null
  - accommodation_date: date, not null
  - initial_quantity: integer
  - current_quantity: integer
  - debicking: variable‐length string up to 255 characters
  - chicken_lineage_id: integer
  - shed

================================================================================

seed:
/* Creates a table named creation_monitoring with 10 columns: id (integer primary key), age_week (integer), age_day (integer), date_week (date), body_weight (integer), food (integer), water (integer), discard (integer), mortality (integer), and chicken_lot_id (integer). The chicken_lot_id column is a foreign key that references the id column of the chicken_lot table. */
CREATE TABLE creation_monitoring (
  id INT NOT NULL AUTO_INCREMENT,
  age_week INT NOT NULL,
  age_day INT NOT NULL,
  date_week DATE NOT NULL,
  body_weight INT NOT NULL,
  food INT NOT NULL,
  water INT NOT NULL,
  discard INT NOT NULL,
  mortality INT NOT NULL,
  chicken_lot_id  INT NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (chicken_lot_id) REFERENCES chicken_lot(id)
) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4

description: Creates a table named creation_monitoring with 10 columns: id (integer primary key), age_week (integer), age_day (integer), date_week (date), body_weight (integer), food (integer), water (integer), discard (integer), mortality (integer), and chicken_lot_id (integer). The chicken_lot_id column is a foreign key that references the id column of the chicken_lot table.

concepts: CREATE TABLE, NOT NULL, AUTO_INCREMENT, PRIMARY KEY, FOREIGN KEY

instruction: Write a SQL query to create a table named creation_monitoring with 10 columns: id (integer primary key), age_week (integer), age_day (integer), date_week (date), body_weight (integer), food (integer), water (integer), discard (integer), mortality (integer), and chicken_lot_id (integer). The chicken_lot_id column is a foreign key that references the id column of the chicken_lot table.

response:
-- Reasoning:
We need a new table named creation_monitoring. It should have an integer primary key so that each row has a unique identifier, and a chicken_lot_id column to store the chicken_lot’s id as an integer.

-- Solution:
CREATE TABLE creation_monitoring (
  id INT PRIMARY KEY,
  age_week INT,
  age_day INT,
  date_week DATE,
  body_weight INT,
  food INT,
  water INT,
  discard INT,
  mortality INT,
  chicken_lot_id INT,
  FOREIGN KEY (chicken_lot_id) REFERENCES chicken_lot(id)
);

-- Explanation:
This statement defines the creation_monitoring table with 10 columns:
  - id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - age_week: integer
  - age_day: integer
  - date_week: date
  - body_weight: integer
  - food: integer
  - water: integer
  - discard: integer
  - mortality: integer
  - chicken_lot_id: integer, foreign key to ch

================================================================================

seed:
/* Creates a table named production_monitoring with 14 columns: id (integer primary key), age_week (integer), age_day (integer), date_week (date), body_weight (integer), food (integer), water (integer), discard (integer), mortality (integer), total_production (integer), first_eggs (integer), second_eggs (integer), egg_weight (integer), and chicken_lot_id (integer). The chicken_ */
CREATE TABLE production_monitoring (
  id INT NOT NULL AUTO_INCREMENT,
  age_week INT NOT NULL,
  age_day INT NOT NULL,
  date_week DATE NOT NULL,
  body_weight INT NOT NULL,
  food INT NOT NULL,
  water INT NOT NULL,
  discard INT NOT NULL,
  mortality INT NOT NULL,
  total_production INT NOT NULL,
  first_eggs INT NOT NULL,
  second_eggs INT NOT NULL,
  egg_weight INT NOT NULL,
  chicken_lot_id  INT NOT NULL,
  PRIMARY KEY (id),
  FOREIGN KEY (chicken_lot_id) REFERENCES chicken_lot(id)
) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4

description: Creates a table named production_monitoring with 14 columns: id (integer primary key), age_week (integer), age_day (integer), date_week (date), body_weight (integer), food (integer), water (integer), discard (integer), mortality (integer), total_production (integer), first_eggs (integer), second_eggs (integer), egg_weight (integer), and chicken_lot_id (integer). The chicken_

concepts: CREATE TABLE, INT, NOT NULL, AUTO_INCREMENT, PRIMARY KEY, FOREIGN

instruction: Write a SQL query to create a table named production_monitoring with 14 columns: id (integer primary key), age_week (integer), age_day (integer), date_week (date), body_weight (integer), food (integer), water (integer), discard (integer), mortality (integer), total_production (integer), first_eggs (integer), second_eggs (integer), egg_weight (integer), and chicken_lot_id (integer

response:
-- Reasoning:
We need a new table named production_monitoring. It should have an integer primary key so that each row has a unique identifier, and a name column to store the product’s name as text.

-- Solution:
CREATE TABLE production_monitoring (
  id INT PRIMARY KEY,
  age_week INT,
  age_day INT,
  date_week DATE,
  body_weight INT,
  food INT,
  water INT,
  discard INT,
  mortality INT,
  total_production INT,
  first_eggs INT,
  second_eggs INT,
  egg_weight INT,
  chicken_lot_id INT
);

-- Explanation:
This statement defines the production_monitoring table with 14 columns:
  - id: integer, marked PRIMARY KEY so it cannot be null and is unique
  - age_week: integer
  - age_day: integer
  - date_week: date
  - body_weight: integer
  - food: integer
  - water: integer
  - discard: integer
  - mortality: integer
  - total_production: integer
  - first_eggs: integer
  - second

================================================================================

seed:
/* Inserts a new row into the shed_manufacturer table with the manufacturer Artabas. */
INSERT INTO shed_manufacturer (manufacturer) values ('Artabas')

description: Inserts a new row into the shed_manufacturer table with the manufacturer Artabas.

concepts: INSERT INTO, VALUES

instruction: 

response:
-- Reasoning:
We need to modify the existing orders table by adding a new column named status. It should be a VARCHAR(20) and not allow NULLs so that every order has a defined status.

-- Solution:
ALTER TABLE orders
  ADD COLUMN status VARCHAR(20) NOT NULL;

-- Explanation:
This ALTER statement updates the orders table schema by adding:
  - status: a non‐nullable varchar column up to 20 chars

-- Tests:
-- 1. Check new column appears and disallows nulls
PRAGMA table_info('orders');

================================================================================

seed:
/* Inserts a new row into the shed_manufacturer table with the value Kilbra for the manufacturer column. */
INSERT INTO shed_manufacturer (manufacturer) values ('Kilbra')

description: Inserts a new row into the shed_manufacturer table with the value Kilbra for the manufacturer column.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new row into the shed_manufacturer table with the value Kilbra for the manufacturer column.

response:
-- Reasoning:
We need to insert a new row into the shed_manufacturer table. It should have a value of Kilbra for the manufacturer column.

-- Solution:
INSERT INTO shed_manufacturer (manufacturer)
VALUES ('Kilbra');

-- Explanation:
This INSERT statement inserts a new row into the shed_manufacturer table with the value Kilbra for the manufacturer column.

-- Tests:
-- 1. Verify new row appears
SELECT * FROM shed_manufacturer;

================================================================================

seed:
/* Inserts a new manufacturer named Plasson into the shed_manufacturer table. */
INSERT INTO shed_manufacturer (manufacturer) values ('Plasson')

description: Inserts a new manufacturer named Plasson into the shed_manufacturer table.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new manufacturer named Plasson into the shed_manufacturer table.

response:
-- Reasoning:
We need to insert a new manufacturer into the shed_manufacturer table. It should have a name of Plasson.

-- Solution:
INSERT INTO shed_manufacturer (name)
VALUES ('Plasson');

-- Explanation:
This INSERT statement inserts a new row into the shed_manufacturer table with a name of Plasson.

-- Tests:
-- 1. Verify new manufacturer appears
SELECT * FROM shed_manufacturer;

================================================================================

seed:
/* Inserts a new manufacturer named Próprio into the shed_manufacturer table. */
INSERT INTO shed_manufacturer (manufacturer) values ('Próprio')

description: Inserts a new manufacturer named Próprio into the shed_manufacturer table.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new manufacturer named Próprio into the shed_manufacturer table.

response:
-- Reasoning:
We need to insert a new manufacturer into the shed_manufacturer table. It should have a name of Próprio.

-- Solution:
INSERT INTO shed_manufacturer (name)
VALUES ('Próprio');

-- Explanation:
This INSERT statement inserts a new row into the shed_manufacturer table with a name of Próprio.

-- Tests:
-- 1. Verify new manufacturer appears
SELECT * FROM shed_manufacturer;

================================================================================

seed:
/* Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns. */
INSERT INTO chicken_lineage (lineage, chicken_color, provider) values ('Nick-Chick', 'Branca', 'H e N')

description: Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns.

response:
-- Reasoning:
We need to insert a new row into the chicken_lineage table. It should have the lineage, chicken_color, and provider columns.

-- Solution:
INSERT INTO chicken_lineage (lineage, chicken_color, provider)
VALUES ('Bantam', 'White', 'Chicken Coop');

-- Explanation:
This INSERT statement inserts a new row into the chicken_lineage table with the specified values.

-- Tests:
-- 1. Verify new row appears
SELECT * FROM chicken_lineage;

================================================================================

seed:
/* Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns. */
INSERT INTO chicken_lineage (lineage, chicken_color, provider) values ('Nick-Brown', 'Vermelha', 'H e N')

description: Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns.

response:
-- Reasoning:
We need to insert a new row into the chicken_lineage table. It should have the lineage, chicken_color, and provider columns.

-- Solution:
INSERT INTO chicken_lineage (lineage, chicken_color, provider)
VALUES ('Bantam', 'White', 'Chicken Coop');

-- Explanation:
This INSERT statement inserts a new row into the chicken_lineage table with the specified values.

-- Tests:
-- 1. Verify new row appears
SELECT * FROM chicken_lineage;

================================================================================

seed:
/* Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider values. */
INSERT INTO chicken_lineage (lineage, chicken_color, provider) values ('W-80',  'Branca', 'Hy-Line')

description: Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider values.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new row into the chicken_lineage table with the lineage, chicken_color, and provider values.

response:
-- Reasoning:
We need to insert a new row into the chicken_lineage table with the lineage, chicken_color, and provider values.

-- Solution:
INSERT INTO chicken_lineage (lineage, chicken_color, provider)
VALUES ('Bantam', 'White', 'Bantam Chicken');

-- Explanation:
This INSERT statement inserts a new row into the chicken_lineage table with the specified values.

-- Tests:
-- 1. Verify new row appears
SELECT * FROM chicken_lineage;

================================================================================

seed:
/* Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns. */
INSERT INTO chicken_lineage (lineage, chicken_color, provider) values ('Hy-Line Brown',  'Vermelha', 'Hy-Line')

description: Inserts a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new row into the chicken_lineage table with the lineage, chicken_color, and provider columns.

response:
-- Reasoning:
We need to insert a new row into the chicken_lineage table. It should have the lineage, chicken_color, and provider columns.

-- Solution:
INSERT INTO chicken_lineage (lineage, chicken_color, provider)
VALUES ('Bantam', 'White', 'Chicken Coop');

-- Explanation:
This INSERT statement inserts a new row into the chicken_lineage table with the specified values.

-- Tests:
-- 1. Verify new row appears
SELECT * FROM chicken_lineage;

================================================================================

seed:
/* Inserts a new shed into the shed table with the given values. */
INSERT INTO shed (name, type, capacity, model, shed_manufacturer_id ) values ('A1', 'Automatizado', 10080, 'P45-10', 1)

description: Inserts a new shed into the shed table with the given values.

concepts: INSERT INTO, VALUES

instruction: 

response:
-- Reasoning:
We need to modify the existing orders table by adding a new column named status. It should be a VARCHAR(20) and not allow NULLs so that every order has a defined status.

-- Solution:
ALTER TABLE orders
  ADD COLUMN status VARCHAR(20) NOT NULL;

-- Explanation:
This ALTER statement updates the orders table schema by adding:
  - status: a non‐nullable varchar column up to 20 chars

-- Tests:
-- 1. Check new column appears and disallows nulls
PRAGMA table_info('orders');

================================================================================

seed:
/* Inserts a new shed into the shed table with the given values. */
INSERT INTO shed (name, type, capacity, model, shed_manufacturer_id ) values ('A2', 'Automatizado', 10080, 'P45-10', 1)

description: Inserts a new shed into the shed table with the given values.

concepts: INSERT INTO, VALUES

instruction: 

response:
-- Reasoning:
We need to modify the existing orders table by adding a new column named status. It should be a VARCHAR(20) and not allow NULLs so that every order has a defined status.

-- Solution:
ALTER TABLE orders
  ADD COLUMN status VARCHAR(20) NOT NULL;

-- Explanation:
This ALTER statement updates the orders table schema by adding:
  - status: a non‐nullable varchar column up to 20 chars

-- Tests:
-- 1. Check new column appears and disallows nulls
PRAGMA table_info('orders');

================================================================================

seed:
/* Inserts a new shed into the shed table with the given values. */
INSERT INTO shed (name, type, capacity, model, shed_manufacturer_id ) values ('C1', 'Convencional', 3072, 'Madeira', 4)

description: Inserts a new shed into the shed table with the given values.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new shed into the shed table with the given values.

response:
-- Reasoning:
We need to insert a new shed into the shed table with the given values.

-- Solution:
INSERT INTO shed (shed_id, name, location)
VALUES (1, '', '123 Main St');

-- Explanation:
This INSERT statement inserts a new row into the shed table with the given values:
  - shed_id: 1
  - name:
  - location: 123 Main St

-- Tests:
-- 1. Verify new row appears
SELECT * FROM shed;

================================================================================

seed:
/* Inserts a new shed into the shed table with the given values. */
INSERT INTO shed (name, type, capacity, model, shed_manufacturer_id ) values ('C2', 'Convencional', 3072, 'Madeira', 4)

description: Inserts a new shed into the shed table with the given values.

concepts: INSERT INTO, VALUES

instruction: Write a SQL query to insert a new shed into the shed table with the given values.

response:
-- Reasoning:
We need to insert a new shed into the shed table with the given values.

-- Solution:
INSERT INTO shed (shed_id, name, location)
VALUES (1, '', '123 Main St');

-- Explanation:
This INSERT statement inserts a new row into the shed table with the given values:
  - shed_id: 1
  - name:
  - location: 123 Main St

-- Tests:
-- 1. Verify new row appears
SELECT * FROM shed;

================================================================================

